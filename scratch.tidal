

let
  lfospeed pat = ccv pat # ccn 102
  lfomult pat = ccv pat # ccn 103
  lfofade pat = ccv pat # ccn 104
  lfodest pat = ccv pat # ccn 105
  lfowave pat = ccv pat # ccn 106
  lfodepth pat = ccv pat # ccn 109
  cfg pat = ccv pat # ccn 21
  tune pat = ccv pat # ccn 17
  balance pat = ccv pat # ccn 19
  detune pat = ccv pat # ccn 20
  ccrand min max x = (segment 1 $ range min max $ shrand x)
  hold pat = ccv pat # ccn 79
  decay pat = ccv pat # ccn 80
  rvbsend pat = ccv pat # ccn 83
  delaysend pat = ccv pat # ccn 82
  size pat = ccv pat # ccn 25
  env pat = ccv pat # ccn 77
  atk pat = ccv pat # ccn 70
  dec pat= ccv pat # ccn 71
  deltime pat = ccv pat # ccn 16
  lfochoices = [10,12,14,25,28,30,37]
  cutoff pat = ccv pat # ccn 74
  

p "bass"
  $ limit 
  $ slow 2 
  $ stack [
    stack [ 
      (|+ note "<-24 -12>") 
        $ dg5
        $ gain "1(3,8, <10 30 40>)" 
          # note (scale "ritusen" "<0 1 -1 2 -2 3 -3>") # legato (range 0.25 0.5 $ shrand 389211)
      , lfospeed (ccrand 0 100 100)
      , lfomult (ccrand 0 6 101)
      , lfodepth (ccrand 0 127 102)
      , lfodest (segment 1 $ shiftBy 38111 $ choose lfochoices)
      -- , ccn 105 # ccv 2
      , lfowave (ccrand 0 6 103)
      , lfofade (ccrand 40 90 104)
      , cfg (ccrand 0 78 105)
      , tune (ccrand 20 64 119)
      , balance (ccrand 0 127 106)
      , detune (ccrand 0 127 107)
      , rvbsend (ccrand 0 127 108)
      , delaysend (ccrand 0 127 109)
      , env (ccrand 0 127 110)
      , atk (ccrand 0 127 111)
      , dec (ccrand 0 127 112)
      , decay (ccrand 1 120 211)
      , cutoff (ccrand 20 100 118)
    ] # midichan 0 # s "rytm"
    , stack [
      size (ccrand 0 100 201)
      , deltime (ccrand 0 127 200)
    ] # midichan 12 # s "rytm"
    , g $ stack [
      ccn 1 # ccv (range 0 120 $ shrand 777)
      , ccn 2 # ccv (range 0 120 $ shrand 771)
      , ccn 3 # ccv (range 0 127 $ shrand 772)
      , ccn 4 # ccv (shiftBy 33 $ choose [0,127])
    ] # s "harmor" # midichan 0
  ]
  # cps (160/120/2)

d1 $ fast 4 $ s "harmor" # midichan 0 # ccn 4 # ccv (range 0 127 $ shrand 83711)

  hush

p "drums" 
  $ limit 
  $ every 3 rev
  $ stack [ 
    dg5 $ slow 2 $ struct "{1@5 1@3 1@10 1@8 1@20}%16" $ midichan 4 # note "c3" # legato (range 0.75 1 $ shrand 1771)
    , struct "{1@5 1@3 1@10 1@8 1@20}%16" $ midichan 2 # note "c3" 
    , g $ midichan "3" # note "c3" 
  ] # s "rytm"

  hush


  d1 $ fast (choose [2,3..10]) $ s "pad" # n 2 # note (scale "ritusen" "<0 -1 -2 -3>") # begin (range 0.1 0.4 $ slow 33 rand) # cut 1



let 
    first = stack [ ccn 1 # ccv 102, ccn 2 # ccv 0, ccn 3 # ccv 0, ccn 4 # ccv 0, ccn 5 # ccv 0, ccn 6 # ccv 0, ccn 7 # ccv 0, ccn 8 # ccv 0, ccn 9 # ccv 0 ] # s "harmor" # midichan 0
    second = stack [ ccn 1 # ccv 0, ccn 2 # ccv 102, ccn 3 # ccv 0, ccn 4 # ccv 0, ccn 5 # ccv 0, ccn 6 # ccv 0, ccn 7 # ccv 0, ccn 8 # ccv 0, ccn 9 # ccv 0 ] # s "harmor" # midichan 0
    third = stack [ ccn 1 # ccv 0, ccn 2 # ccv 0, ccn 3 # ccv 102, ccn 4 # ccv 0, ccn 5 # ccv 0, ccn 6 # ccv 0, ccn 7 # ccv 0, ccn 8 # ccv 0, ccn 9 # ccv 0 ] # s "harmor" # midichan 0
    fourth = stack [ ccn 1 # ccv 0, ccn 2 # ccv 0, ccn 3 # ccv 0, ccn 4 # ccv 102, ccn 5 # ccv 0, ccn 6 # ccv 0, ccn 7 # ccv 0, ccn 8 # ccv 0, ccn 9 # ccv 0 ] # s "harmor" # midichan 0
    fifth = stack [ ccn 1 # ccv 0, ccn 2 # ccv 0, ccn 3 # ccv 0, ccn 4 # ccv 0, ccn 5 # ccv 102, ccn 6 # ccv 0, ccn 7 # ccv 0, ccn 8 # ccv 0, ccn 9 # ccv 0 ] # s "harmor" # midichan 0
    sixth = stack [ ccn 1 # ccv 9, ccn 2 # ccv 0, ccn 3 # ccv 0, ccn 4 # ccv 0, ccn 5 # ccv 0, ccn 6 # ccv 102, ccn 7 # ccv 0, ccn 8 # ccv 0, ccn 9 # ccv 0 ] # s "harmor" # midichan 0
    seventh = stack [ ccn 1 # ccv 0, ccn 2 # ccv 0, ccn 3 # ccv 0, ccn 4 # ccv 0, ccn 5 # ccv 0, ccn 6 # ccv 0, ccn 7 # ccv 102, ccn 8 # ccv 0, ccn 9 # ccv 0 ] # s "harmor" # midichan 0
    eighth = stack [ ccn 1 # ccv 0, ccn 2 # ccv 0, ccn 3 # ccv 0, ccn 4 # ccv 0, ccn 5 # ccv 0, ccn 6 # ccv 0, ccn 7 # ccv 0, ccn 8 # ccv 102, ccn 9 # ccv 0 ] # s "harmor" # midichan 0
    ninth = stack [ ccn 1 # ccv 0, ccn 2 # ccv 0, ccn 3 # ccv 0, ccn 4 # ccv 0, ccn 5 # ccv 0, ccn 6 # ccv 0, ccn 7 # ccv 0, ccn 8 # ccv 0, ccn 9 # ccv 102 ] # s "harmor" # midichan 0
    getit = slow (shiftBy 38 $ choose [0.5,0.6..1.5]) $ randcat [first, second, third, fourth, fifth, sixth, seventh, eighth, ninth]
    verb1 = stack [ ccn 1 # ccv 85, ccn 2 # ccv 0 ] # s "harmor" # midichan 2
    verb2 = stack [ ccn 1 # ccv 0, ccn 2 # ccv 102 ] # s "harmor" # midichan 2
    getitverb = slow (shiftBy 3811 $ choose [0.5,0.6..2]) $ randcat [verb1, verb2]

do
  d1  
    $ whenmod 32 24 (slow 1.5)
    $ whenmod 24 16 (slow 1.5)
    $ dg0
    $ shift
    $ limit
    $ every 3 rev
    $ stack [
      dg5 $ shiftBy 333 $ one 0.25 $ shiftBy 389 $ gain "{1@3 1@5 1@7 1@9 1@11 1@13 1@15}%16" # midichan 2 # note "c3"
      , dg5 $ shiftBy 1001 $ roll 0.3 $ shiftBy 4 $ dg3 $ midichan 3 # note "c3"
      , dg5 $ shiftBy 9 $ struct (binaryN 16 "<23721 7238711 432054>") $ midichan 10 # note "c3"
      , dg0 $ foldEvery [2,3] (slow 1.5) $ midichan 4 # note "c3" # legato 0.2
    ] # rytm # cps (140/120/2)

  d2 
    $ stack [getit, getitverb ]


d2 $ fast 5 $ ccn 1 # ccv (range 0 127 $ shrand 83) # s "harmor" # midichan 2

  
  
  
  
  
  
  
  hush


  0.800003051757813










let target =
      Target {oName = "visualiser",   -- A friendly name for the target (only used in error messages)
              oAddress = "localhost", -- The target's network address, normally "localhost"
              oPort = 5050,           -- The network port the target is listening on
              oLatency = 0.2,         -- Additional delay, to smooth out network jitter/get things in sync
              oSchedule = Live,       -- The scheduling method - see below
              oWindow = Nothing       -- Not yet used
             }

let oscplay = OSC "/play" $ ArgList [("s", Nothing),
                                     ("vowel", Just $ VS "a"),
                                     ("pan", Just $ VF 0.5),
                                     ("cut", Just $ VI 1),
                                     ("intensity", Just $ VI 0),
                                     ("sec", Just $ VF 0),
                                     ("usec", Just $ VF 0),
                                     ("cps", Just $ VF 0),
                                     ("cycle", Just $ VF 0),
                                     ("delta", Just $ VF 0)
                                   ]

let oscmap = [(target, [oscplay]),
              (superdirtTarget, [superdirtShape])
             ]

stream <- startStream defaultConfig oscmap

d = streamReplace stream

d 1 $ s "bd"             


d1 $ s "herb1" # cut 1 # speed (range 0.5 1 $ slow 3 rand)